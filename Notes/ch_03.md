# Abstrações

1. Como fazer uma boa abstração?³
2. O que nós queremos das abstrações?¹
3. E como eles estão relacionados com os testes?²

## Acoplamento

- Localmente, é uma coisa boa: é sinal que nosso código está funcionando juntos,
cada componente apoiando os outros, todos eles juntos no lugar como engrenagens 
de um relógio. No jargão, nós dizemos que isso funciona quando existe uma **alta
coesão** entre os elementos acoplados.
- Globalmente, **acoplamento** é um incômodo: isso aumenta o risco e o custo de mudar
nosso código, algumas vezes ao ponto de nós se sentimos incapazes de fazer alterações.
Então enquanto nossa aplicação cresce, se nós somos incapazes de prevenir o acoplamento
entre elementos que não tem coesão, esse acoplamento aumenta superlinearmente até não sermos
mais capazes de fazer mudanças nos nossos sistemas.
- Podemos reduzir o grau de acoplamento dentro de um sistema( **alto acoplamento** ) abstraindo os 
detalhes( **baixo acoplamento** ).
- Com o **baixo acoplamento**, nós podemos reduzir o nível de acoplamento inserindo uma nova e simples **abstração**.
**A abstração serve para nós proteger das mudanças, ocultando os detalhes complexos de qualquer sistema¹**.
- ***Código de alto nível acoplado com detalhes de baixo nível dificulta a nossa vida. Á medida que os cenários
que consideramos ficarem mais complexos, nossos testes ficarão mais difíceis. Nós podemos refatorar esses testes
mas enquanto estivermos executando operações do sistema de arquivos, eles ficarão lentos e difíceis de ler e manter²***.
- Nós necessitamos pensar sobre como nosso codigo depende dos detalhes de baixo nível. Então é preciso ler o código
e ver quais cosias distintas estão acontecendo. Podemos separar essas coisas distintas como responsabilidades que o código
tem. Lembre-se de que queremos encontrar abstrações simples para cada uma das responsabilidades. Isso nós permitirá ocultar
os detalhes complicados para que possamos focar na lógica³.
- Depois de escolher as abstrações, podemos mudar nossa implementação isolando as regras de negócio e permitir testa-las
sem a dependência dos detalhes de baixo nível. Criaremos um "core" do código que não depende do estado externo e, em seguida,
veremos como ele responde quando fornecemos informações do mundo exterior(esse tipo de abordagem foi caracterizada nesse link 
http://oreil.ly/wnad4 ) .
- A implementação irá conter uma função de alto nível que não irá conter nenhuma lógica, apenas uma série de 
etapas iterativas: reunir entradas, chamar nossa lógica, aplicar saídas.
- Depois de separar a lógica do nosso programa dos detalhes de baixo nível, nós podemos facilmente testar nosso o "core" do nosso código.

## Observações

- Escrever código no mundo real: comece com uma solução para a menor parte do problema e, depois, iterativamente, 
torne a solução mais rica e melhor projetada.

## Nomenclaturas

- **Acoplamento**: https://martinfowler.com/ieeeSoftware/coupling.pdf
- **Alta coesão**: http://www.dsc.ufcg.edu.br/~jacques/cursos/map/html/pat/altacoesao.htm

